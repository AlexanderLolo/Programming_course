# Рефлексия
1. В эталонном решении для теста (почти) пустого массива использовались две инструкции `self.assertEqual(len(a1), 1)` и `self.assertEqual(a1[0], 1)`
   В моем решении я обошелся одной `self.assertEqual(sorting( [9] ), [9] )` руководствуясь тем, что `assertListEqual(first, second, msg=None)` **is used by default when comparing lists    or tuples with assertEqual().**

2. В случайном тесте в эталонном решении результат сравнивался с результатом стандартной функции, в то время как в моем проверялись условия `self.assertLessEqual(list1[i], list1[i+1])`. Думаю, для проверки правильности сортировки эти подходы идентичны.

   **Возник вопрос в целесообразности регрессионного теста, при наличии такого мощного случайного**.

3. Взял на вооружение возможности предоставляемые пайтоном по работе с бесконечностями `float("inf"), float("-inf")`


# Задание 3.1, 3.2
1. [ссылка на .py файл c функциями](files_exec.py)

2. [ссылка на .py файл c тестом](test_files_exec.py) 

# Задание 3.3

1. [ссылка на .py файл c функциями](files_exec2.py)


